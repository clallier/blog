---
permalink: /404.html
layout: default
---

<style type="text/css" media="screen">
  .container {
    margin: 10px auto;
    max-width: 600px;
    text-align: center;
  }

  h1 {
    margin: 30px 0;
    font-size: 4em;
    line-height: 1;
    letter-spacing: -1px;
  }

  canvas {
    display: block;
    margin: 0px;
    width: 100%;
  }
</style>

<div class="container">
  <h1>404</h1>
  <p>The requested page could not be found.</p>
  <canvas id="terrainCanvas" width="600" height="400"></canvas>
</div>

<script async type="module">
  import Matrix from '/blog/assets/js/modules/matrix.js';
  const mtx = new Matrix();

  // Function to create terrain vertices from heightmap
  const createTerrain = (width, height) => {
    const vertices = [];
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const z = (Math.sin(x * 0.1) + Math.sin(y * 0.1)) * 0.5 + 0.5;
        // normalize x and y to range [-1, 1]
        vertices.push(new Float32Array([
          x / width * 2 - 1, y / height * 2 - 1, z, 1]));
      }
    }
    return vertices;
  };

  // Draw the transformed terrain
  const drawTerrain = (ctx, terrain) => {
    terrain.forEach(vertex => {
      ctx.rect(vertex[0] - 1, vertex[1] - 1, 2, 2); // Draw a rectangle of width 2 centered at the vertex
    });
  }

  const canvas = document.getElementById('terrainCanvas');
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = `rgb(255 255 2255 0.6)`;

  const width = 100; // Width of the heightmap
  const height = 100; // Height of the heightmap
  const canvasWidth = canvas.width; // Width of the canvas
  const canvasHeight = canvas.height; // Height of the canvas
  const ratio = canvasWidth / canvasHeight;
  const size = Math.min(canvasWidth, canvasHeight) * 1.7;

  const terrain = createTerrain(width, height);

  // Apply transformations and draw the terrain
  const projection = mtx.scale(1, 1, 1);
  const translation = mtx.translate(canvasWidth / 2, canvasHeight / 2, 0);
  const transformScale = mtx.scale(size, size, 0);
  const rotationZ = mtx.rotateZ(Math.PI / 6);
  const rotationY = mtx.rotateY(Math.PI / 6);
  const rotationX = mtx.rotateX(Math.PI);

  // Apply transformations to the terrain vertices
  const transformedTerrain = terrain.map(vertex => {

    let transformedVertex = mtx.mat4xvec4(rotationX, vertex);
    // transformedVertex = mtx.mat4xvec4(rotationZ, transformedVertex);

    // mtx.updatePerspctive(projection, vertex, 10);
    // transformedVertex = mtx.mat4xvec4(projection, vertex);

    transformedVertex = mtx.mat4xvec4(transformScale, transformedVertex);
    // transformedVertex = mtx.mat4xvec4(rotationY, transformedVertex);

    transformedVertex = mtx.mat4xvec4(translation, transformedVertex);

    return transformedVertex;
  });

  let timeMs = 0, dtMs = 0, lastTimeMs = 0, time = 0;
  let start = 0, end = 0;
  const update = (ms) => {
    // time vars
    timeMs = ms;
    dtMs = timeMs - lastTimeMs;
    lastTimeMs = timeMs;
    time = timeMs * 0.001;


    // start precision timer
    start = performance.now();

    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    drawTerrain(ctx, transformedTerrain);

    // end precision timer
    end = performance.now();
    console.log('update time:', end - start, 'ms');

    // request another frame
    requestAnimationFrame(update);
  }

  console.log("hey");
  // Start the animation loop
  // requestAnimationFrame(update);
</script>